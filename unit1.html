<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit I: Basic Concepts and Automata Theory - TAFL Study Guide</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header class="nav-header">
        <nav class="nav-container">
            <a href="index.html" class="nav-brand">TAFL Study Guide</a>
            <div class="nav-links">
                <a href="unit1.html" class="active">Unit I</a>
                <a href="unit2.html">Unit II</a>
                <a href="unit3.html">Unit III</a>
                <a href="unit4.html">Unit IV</a>
                <a href="unit5.html">Unit V</a>
            </div>
        </nav>
    </header>

    <main class="page-container">
        <div class="content-wrapper">
            <aside class="sidebar">
                <nav class="sidebar-nav">
                    <h3>Unit I Contents</h3>
                    <ul>
                        <li><a href="#intro">1.1 Introduction to Theory of Computation</a></li>
                        <li><a href="#three-pillars">1.2 Automata, Computability, Complexity</a></li>
                        <li><a href="#basic-concepts">1.3 Basic Concepts</a>
                            <ul>
                                <li><a href="#alphabet">Alphabet and Symbols</a></li>
                                <li><a href="#strings">Strings</a></li>
                                <li><a href="#languages">Languages</a></li>
                            </ul>
                        </li>
                        <li><a href="#dfa">1.4 Deterministic Finite Automata</a></li>
                        <li><a href="#nfa">1.5 Non-deterministic Finite Automata</a></li>
                        <li><a href="#dfa-nfa-equivalence">1.6 DFA-NFA Equivalence</a></li>
                        <li><a href="#epsilon-nfa">1.7 Epsilon-NFA</a></li>
                        <li><a href="#moore-machine">1.8 Moore Machine</a></li>
                        <li><a href="#mealy-machine">1.9 Mealy Machine</a></li>
                        <li><a href="#moore-mealy-equivalence">1.10 Moore-Mealy Equivalence</a></li>
                        <li><a href="#dfa-minimization">1.11 DFA Minimization</a></li>
                        <li><a href="#summary">Unit Summary</a></li>
                    </ul>
                </nav>
            </aside>

            <article class="main-content">
                <h1>Unit I: Basic Concepts and Automata Theory</h1>

                <!-- Section 1.1 -->
                <section id="intro">
                    <h2>1.1 Introduction to Theory of Computation</h2>

                    <p>The <strong>Theory of Computation</strong> is a branch of computer science that deals with the fundamental capabilities and limitations of computers. It addresses questions such as:</p>
                    <ul>
                        <li>What problems can be solved by a computer?</li>
                        <li>What problems cannot be solved, even with unlimited time and resources?</li>
                        <li>How efficiently can a problem be solved?</li>
                    </ul>

                    <div class="definition-box">
                        <div class="box-title">Definition: Theory of Computation</div>
                        <p>The Theory of Computation is the study of abstract machines and computational problems, focusing on what can be computed, how it can be computed, and the resources required for computation.</p>
                    </div>

                    <p>This theory provides the mathematical foundation for computer science and has profound implications for understanding the nature of computation itself. The field was largely developed in the 1930s by pioneers such as Alan Turing, Alonzo Church, and Kurt Godel.</p>

                    <div class="note-box">
                        <div class="box-title">Historical Context</div>
                        <p>The theory was developed before electronic computers existed. Turing and Church were trying to formalize the notion of "effective calculability" - what it means for a mathematical function to be computable by a mechanical process.</p>
                    </div>
                </section>

                <!-- Section 1.2 -->
                <section id="three-pillars">
                    <h2>1.2 Automata, Computability, and Complexity</h2>

                    <p>The Theory of Computation is divided into three major areas, each addressing different aspects of computation:</p>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Area</th>
                                <th>Central Question</th>
                                <th>Key Concepts</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Automata Theory</strong></td>
                                <td>What are the different computational models?</td>
                                <td>Finite Automata, Pushdown Automata, Turing Machines, Formal Languages</td>
                            </tr>
                            <tr>
                                <td><strong>Computability Theory</strong></td>
                                <td>What problems CAN and CANNOT be solved by a computer?</td>
                                <td>Decidability, Undecidability, Halting Problem, Recursive Languages</td>
                            </tr>
                            <tr>
                                <td><strong>Complexity Theory</strong></td>
                                <td>How EFFICIENTLY can problems be solved?</td>
                                <td>Time Complexity, Space Complexity, P vs NP, NP-Completeness</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Automata Theory</h3>
                    <p>Automata theory studies abstract computing devices (automata) and their capabilities. An automaton is a mathematical model of a computing device that follows a predetermined sequence of operations automatically. Different types of automata recognize different classes of languages.</p>

                    <h3>Computability Theory</h3>
                    <p>Computability theory (also called recursion theory) investigates the limits of mechanical computation. It establishes that some problems are fundamentally unsolvable by any algorithm - not because we haven't found the solution yet, but because no solution can exist.</p>

                    <h3>Complexity Theory</h3>
                    <p>Complexity theory classifies problems based on the computational resources (time and space) required to solve them. Even if a problem is computable, it may require impractical amounts of resources.</p>

                    <div class="exam-tip-box">
                        <div class="box-title">Exam Tip</div>
                        <p>Distinguish clearly between these three areas. A common exam question asks you to explain the difference between computability and complexity. Remember: Computability asks "Can it be done?" while Complexity asks "How efficiently can it be done?"</p>
                    </div>
                </section>

                <!-- Section 1.3 -->
                <section id="basic-concepts">
                    <h2>1.3 Basic Concepts: Alphabets, Strings, and Languages</h2>

                    <h3 id="alphabet">Alphabet and Symbols</h3>

                    <div class="definition-box">
                        <div class="box-title">Definition: Symbol</div>
                        <p>A <strong>symbol</strong> (or character) is an abstract entity that cannot be defined formally. Examples include letters (a, b, c), digits (0, 1, 2), and special characters (#, $, @).</p>
                    </div>

                    <div class="definition-box">
                        <div class="box-title">Definition: Alphabet</div>
                        <p>An <strong>alphabet</strong> (denoted by <code>Sigma</code>) is a finite, non-empty set of symbols.</p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Examples of Alphabets</div>
                        <ul>
                            <li><code>Sigma = {0, 1}</code> - Binary alphabet</li>
                            <li><code>Sigma = {a, b, c, ..., z}</code> - Lowercase English alphabet</li>
                            <li><code>Sigma = {0, 1, 2, ..., 9}</code> - Decimal digits</li>
                            <li><code>Sigma = {a, b}</code> - Two-symbol alphabet</li>
                        </ul>
                    </div>

                    <h3 id="strings">Strings</h3>

                    <div class="definition-box">
                        <div class="box-title">Definition: String</div>
                        <p>A <strong>string</strong> (or word) over an alphabet <code>Sigma</code> is a finite sequence of symbols from <code>Sigma</code>. The <strong>empty string</strong>, denoted by <code>epsilon</code> (or sometimes <code>lambda</code>), is the unique string containing zero symbols.</p>
                    </div>

                    <h4>String Operations</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Notation</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Length</td>
                                <td><code>|w|</code></td>
                                <td>Number of symbols in string w</td>
                                <td><code>|abc| = 3</code>, <code>|epsilon| = 0</code></td>
                            </tr>
                            <tr>
                                <td>Concatenation</td>
                                <td><code>w1 . w2</code> or <code>w1w2</code></td>
                                <td>Joining two strings</td>
                                <td><code>ab . cd = abcd</code></td>
                            </tr>
                            <tr>
                                <td>Power</td>
                                <td><code>w^n</code></td>
                                <td>String w repeated n times</td>
                                <td><code>(ab)^3 = ababab</code></td>
                            </tr>
                            <tr>
                                <td>Reversal</td>
                                <td><code>w^R</code></td>
                                <td>String w written backwards</td>
                                <td><code>(abc)^R = cba</code></td>
                            </tr>
                            <tr>
                                <td>Prefix</td>
                                <td>-</td>
                                <td>Initial segment of w</td>
                                <td>Prefixes of <code>abc</code>: <code>epsilon, a, ab, abc</code></td>
                            </tr>
                            <tr>
                                <td>Suffix</td>
                                <td>-</td>
                                <td>Final segment of w</td>
                                <td>Suffixes of <code>abc</code>: <code>epsilon, c, bc, abc</code></td>
                            </tr>
                            <tr>
                                <td>Substring</td>
                                <td>-</td>
                                <td>Contiguous segment of w</td>
                                <td>Substrings of <code>abc</code>: <code>epsilon, a, b, c, ab, bc, abc</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="definition-box">
                        <div class="box-title">Definition: Kleene Closure and Positive Closure</div>
                        <p><strong>Kleene Closure</strong> (<code>Sigma*</code>): The set of all possible strings over alphabet <code>Sigma</code>, including the empty string.</p>
                        <p><strong>Positive Closure</strong> (<code>Sigma+</code>): The set of all possible non-empty strings over alphabet <code>Sigma</code>.</p>
                        <p>Formally: <code>Sigma+ = Sigma* - {epsilon}</code></p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example: Kleene Closure</div>
                        <p>For <code>Sigma = {0, 1}</code>:</p>
                        <p><code>Sigma* = {epsilon, 0, 1, 00, 01, 10, 11, 000, 001, ...}</code></p>
                        <p><code>Sigma+ = {0, 1, 00, 01, 10, 11, 000, 001, ...}</code></p>
                        <p>Note: <code>Sigma*</code> is always an infinite set (even for finite alphabets).</p>
                    </div>

                    <h3 id="languages">Languages</h3>

                    <div class="definition-box">
                        <div class="box-title">Definition: Language</div>
                        <p>A <strong>language</strong> L over an alphabet <code>Sigma</code> is any subset of <code>Sigma*</code>. That is, <code>L is a subset of Sigma*</code>.</p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Examples of Languages</div>
                        <p>Over <code>Sigma = {0, 1}</code>:</p>
                        <ul>
                            <li><code>L1 = {}</code> - The empty language (contains no strings)</li>
                            <li><code>L2 = {epsilon}</code> - Language containing only the empty string</li>
                            <li><code>L3 = {0, 00, 000, ...}</code> - All strings of only 0s</li>
                            <li><code>L4 = {w : |w| is even}</code> - All even-length strings</li>
                            <li><code>L5 = {0^n 1^n : n >= 0}</code> - Equal 0s followed by equal 1s</li>
                        </ul>
                    </div>

                    <h4>Operations on Languages</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Notation</th>
                                <th>Definition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Union</td>
                                <td><code>L1 U L2</code></td>
                                <td><code>{w : w in L1 OR w in L2}</code></td>
                            </tr>
                            <tr>
                                <td>Intersection</td>
                                <td><code>L1 intersection L2</code></td>
                                <td><code>{w : w in L1 AND w in L2}</code></td>
                            </tr>
                            <tr>
                                <td>Complement</td>
                                <td><code>L'</code> or <code>L^c</code></td>
                                <td><code>Sigma* - L</code></td>
                            </tr>
                            <tr>
                                <td>Concatenation</td>
                                <td><code>L1 . L2</code></td>
                                <td><code>{w1w2 : w1 in L1, w2 in L2}</code></td>
                            </tr>
                            <tr>
                                <td>Kleene Closure</td>
                                <td><code>L*</code></td>
                                <td><code>L^0 U L^1 U L^2 U ...</code></td>
                            </tr>
                            <tr>
                                <td>Positive Closure</td>
                                <td><code>L+</code></td>
                                <td><code>L^1 U L^2 U L^3 U ...</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="warning-box">
                        <div class="box-title">Common Mistake</div>
                        <p>Do not confuse the empty language <code>{}</code> with the language containing the empty string <code>{epsilon}</code>:</p>
                        <ul>
                            <li><code>{}</code> contains 0 strings</li>
                            <li><code>{epsilon}</code> contains 1 string (the empty string)</li>
                        </ul>
                    </div>
                </section>

                <!-- Section 1.4 -->
                <section id="dfa">
                    <h2>1.4 Deterministic Finite Automaton (DFA)</h2>

                    <p>A Deterministic Finite Automaton is the simplest model of computation. It has a fixed amount of memory (represented by its states) and processes input one symbol at a time.</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Deterministic Finite Automaton (DFA)</div>
                        <p>A DFA is a 5-tuple <code>M = (Q, Sigma, delta, q0, F)</code> where:</p>
                        <ul>
                            <li><code>Q</code> = Finite, non-empty set of states</li>
                            <li><code>Sigma</code> = Input alphabet (finite set of symbols)</li>
                            <li><code>delta: Q x Sigma -> Q</code> = Transition function</li>
                            <li><code>q0 in Q</code> = Initial (start) state</li>
                            <li><code>F is a subset of Q</code> = Set of final (accepting) states</li>
                        </ul>
                    </div>

                    <h3>Key Properties of DFA</h3>
                    <ul>
                        <li><strong>Deterministic:</strong> For each state and input symbol, there is exactly one next state</li>
                        <li><strong>Complete:</strong> The transition function is total - defined for all (state, symbol) pairs</li>
                        <li><strong>No epsilon transitions:</strong> All transitions consume exactly one input symbol</li>
                    </ul>

                    <h3>Extended Transition Function</h3>
                    <div class="definition-box">
                        <div class="box-title">Definition: Extended Transition Function</div>
                        <p>The extended transition function <code>delta*: Q x Sigma* -> Q</code> extends delta to strings:</p>
                        <ul>
                            <li><code>delta*(q, epsilon) = q</code> (for any state q)</li>
                            <li><code>delta*(q, wa) = delta(delta*(q, w), a)</code> (for string w and symbol a)</li>
                        </ul>
                    </div>

                    <h3>Language Accepted by DFA</h3>
                    <div class="definition-box">
                        <div class="box-title">Definition: Language of a DFA</div>
                        <p>The language accepted (or recognized) by a DFA M is:</p>
                        <p><code>L(M) = {w in Sigma* : delta*(q0, w) in F}</code></p>
                        <p>A string w is accepted if, starting from the initial state and reading w, the DFA ends in a final state.</p>
                    </div>

                    <h3>Transition Table Representation</h3>
                    <p>A DFA can be represented as a transition table where rows represent states, columns represent input symbols, and entries show the next state.</p>

                    <div class="example-box">
                        <div class="box-title">Example 1: DFA for strings ending with "01"</div>
                        <p>Design a DFA over <code>Sigma = {0, 1}</code> that accepts all strings ending with "01".</p>

                        <p><strong>Solution:</strong></p>
                        <p>States needed:</p>
                        <ul>
                            <li><code>q0</code>: Initial state - no progress toward "01"</li>
                            <li><code>q1</code>: Last symbol seen was "0"</li>
                            <li><code>q2</code>: Last two symbols were "01" (final state)</li>
                        </ul>

                        <table class="transition-table">
                            <caption>Transition Table</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">q0</td>
                                    <td>q1</td>
                                    <td>q0</td>
                                </tr>
                                <tr>
                                    <td>q1</td>
                                    <td>q1</td>
                                    <td>q2</td>
                                </tr>
                                <tr>
                                    <td class="state-final">q2</td>
                                    <td>q1</td>
                                    <td>q0</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="diagram-container">
                            <svg width="400" height="150" viewBox="0 0 400 150">
                                <!-- Initial arrow -->
                                <line x1="20" y1="75" x2="55" y2="75" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <!-- State q0 -->
                                <circle cx="80" cy="75" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="80" y="80" text-anchor="middle" font-family="Georgia" font-size="14">q0</text>

                                <!-- State q1 -->
                                <circle cx="200" cy="75" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="200" y="80" text-anchor="middle" font-family="Georgia" font-size="14">q1</text>

                                <!-- State q2 (final - double circle) -->
                                <circle cx="320" cy="75" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="320" cy="75" r="20" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="320" y="80" text-anchor="middle" font-family="Georgia" font-size="14">q2</text>

                                <!-- Transitions -->
                                <!-- q0 to q1 on 0 -->
                                <path d="M 105 75 L 170 75" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="137" y="65" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q1 to q2 on 1 -->
                                <path d="M 225 75 L 290 75" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="257" y="65" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- q0 self-loop on 1 -->
                                <path d="M 65 55 C 50 20, 110 20, 95 55" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="80" y="25" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- q1 self-loop on 0 -->
                                <path d="M 185 55 C 170 20, 230 20, 215 55" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="200" y="25" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q2 to q1 on 0 -->
                                <path d="M 300 90 C 280 120, 220 120, 220 90" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="260" y="130" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q2 to q0 on 1 -->
                                <path d="M 295 70 C 260 50, 200 30, 140 30 C 120 30, 105 45, 95 55" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead)"/>
                                <text x="200" y="20" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.1: DFA accepting strings ending with "01"</p>
                        </div>

                        <p><strong>Trace for string "1101":</strong></p>
                        <pre>delta*(q0, 1101) = delta*(delta(q0, 1), 101)
               = delta*(q0, 101)
               = delta*(delta(q0, 1), 01)
               = delta*(q0, 01)
               = delta*(delta(q0, 0), 1)
               = delta*(q1, 1)
               = delta(q1, 1)
               = q2 (final state)

String "1101" is ACCEPTED.</pre>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example 2: DFA for even number of 0s</div>
                        <p>Design a DFA over <code>Sigma = {0, 1}</code> that accepts strings with an even number of 0s.</p>

                        <p><strong>Solution:</strong></p>
                        <p>We need to track whether we have seen an even or odd number of 0s so far.</p>

                        <table class="transition-table">
                            <caption>Transition Table</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial state-final">q_even</td>
                                    <td>q_odd</td>
                                    <td>q_even</td>
                                </tr>
                                <tr>
                                    <td>q_odd</td>
                                    <td>q_even</td>
                                    <td>q_odd</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="diagram-container">
                            <svg width="320" height="120" viewBox="0 0 320 120">
                                <!-- Initial arrow -->
                                <line x1="20" y1="60" x2="55" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead2)"/>

                                <!-- State q_even (initial and final) -->
                                <circle cx="100" cy="60" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="100" cy="60" r="20" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="100" y="55" text-anchor="middle" font-family="Georgia" font-size="11">q</text>
                                <text x="100" y="70" text-anchor="middle" font-family="Georgia" font-size="9">even</text>

                                <!-- State q_odd -->
                                <circle cx="220" cy="60" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="220" y="55" text-anchor="middle" font-family="Georgia" font-size="11">q</text>
                                <text x="220" y="70" text-anchor="middle" font-family="Georgia" font-size="9">odd</text>

                                <!-- Transitions -->
                                <!-- q_even to q_odd on 0 -->
                                <path d="M 125 50 L 195 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead2)"/>
                                <text x="160" y="42" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q_odd to q_even on 0 -->
                                <path d="M 195 70 L 125 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead2)"/>
                                <text x="160" y="88" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q_even self-loop on 1 -->
                                <path d="M 85 40 C 70 5, 130 5, 115 40" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead2)"/>
                                <text x="100" y="10" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- q_odd self-loop on 1 -->
                                <path d="M 205 40 C 190 5, 250 5, 235 40" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead2)"/>
                                <text x="220" y="10" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.2: DFA accepting strings with even number of 0s</p>
                        </div>

                        <p><strong>Note:</strong> The empty string has zero 0s, and zero is even, so epsilon is accepted.</p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example 3: DFA for strings containing substring "aba"</div>
                        <p>Design a DFA over <code>Sigma = {a, b}</code> that accepts strings containing "aba" as a substring.</p>

                        <p><strong>Solution:</strong></p>
                        <p>We track how much of "aba" we have seen so far.</p>
                        <ul>
                            <li>q0: Haven't started matching "aba"</li>
                            <li>q1: Seen "a" (first character of "aba")</li>
                            <li>q2: Seen "ab" (first two characters)</li>
                            <li>q3: Seen "aba" (complete match) - FINAL</li>
                        </ul>

                        <table class="transition-table">
                            <thead>
                                <tr><th>State</th><th>a</th><th>b</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">q0</td>
                                    <td>q1</td>
                                    <td>q0</td>
                                </tr>
                                <tr>
                                    <td>q1</td>
                                    <td>q1</td>
                                    <td>q2</td>
                                </tr>
                                <tr>
                                    <td>q2</td>
                                    <td>q3</td>
                                    <td>q0</td>
                                </tr>
                                <tr>
                                    <td class="state-final">q3</td>
                                    <td>q3</td>
                                    <td>q3</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Trace for "bbaba":</strong> q0 -b-> q0 -b-> q0 -a-> q1 -b-> q2 -a-> q3 (ACCEPT)</p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example 4: DFA for binary numbers divisible by 3</div>
                        <p>Design a DFA over <code>Sigma = {0, 1}</code> that accepts binary representations of numbers divisible by 3.</p>

                        <p><strong>Solution:</strong></p>
                        <p>Track remainder when dividing by 3. If current number is n and we read bit b, new number is 2n + b.</p>
                        <ul>
                            <li>q0: remainder 0 (divisible by 3) - INITIAL and FINAL</li>
                            <li>q1: remainder 1</li>
                            <li>q2: remainder 2</li>
                        </ul>

                        <p>Transitions based on (2r + b) mod 3:</p>
                        <table class="transition-table">
                            <thead>
                                <tr><th>State (remainder)</th><th>0</th><th>1</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial state-final">q0 (r=0)</td>
                                    <td>q0 (2*0+0=0)</td>
                                    <td>q1 (2*0+1=1)</td>
                                </tr>
                                <tr>
                                    <td>q1 (r=1)</td>
                                    <td>q2 (2*1+0=2)</td>
                                    <td>q0 (2*1+1=3 mod 3=0)</td>
                                </tr>
                                <tr>
                                    <td>q2 (r=2)</td>
                                    <td>q1 (2*2+0=4 mod 3=1)</td>
                                    <td>q2 (2*2+1=5 mod 3=2)</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Example:</strong> "110" (= 6 in decimal)</p>
                        <p>q0 -1-> q1 -1-> q0 -0-> q0 (remainder 0, ACCEPT)</p>
                        <p>6 / 3 = 2 remainder 0. Correct!</p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example 5: DFA for strings with even 0s AND even 1s</div>
                        <p>Design a DFA over <code>Sigma = {0, 1}</code> that accepts strings with both even number of 0s and even number of 1s.</p>

                        <p><strong>Solution:</strong></p>
                        <p>Need to track parity of both symbols. States represent (parity of 0s, parity of 1s):</p>
                        <ul>
                            <li>q00: even 0s, even 1s (INITIAL and FINAL)</li>
                            <li>q01: even 0s, odd 1s</li>
                            <li>q10: odd 0s, even 1s</li>
                            <li>q11: odd 0s, odd 1s</li>
                        </ul>

                        <table class="transition-table">
                            <thead>
                                <tr><th>State</th><th>0</th><th>1</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial state-final">q00</td>
                                    <td>q10</td>
                                    <td>q01</td>
                                </tr>
                                <tr>
                                    <td>q01</td>
                                    <td>q11</td>
                                    <td>q00</td>
                                </tr>
                                <tr>
                                    <td>q10</td>
                                    <td>q00</td>
                                    <td>q11</td>
                                </tr>
                                <tr>
                                    <td>q11</td>
                                    <td>q01</td>
                                    <td>q10</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Key insight:</strong> This is a product construction of two simpler DFAs!</p>
                    </div>

                    <div class="exam-tip-box">
                        <div class="box-title">Exam Tips for DFA Construction</div>
                        <ul>
                            <li>First identify what needs to be "remembered" - this determines the states</li>
                            <li>Always include a start state and clearly mark final states</li>
                            <li>Ensure the transition function is complete (every state has a transition for every symbol)</li>
                            <li>Test your DFA with sample strings (both accepting and rejecting)</li>
                            <li>If a language requires "unbounded counting," DFA cannot recognize it</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <div class="box-title">Common Mistakes in DFA Construction</div>
                        <ul>
                            <li>Forgetting to define transitions for all input symbols from all states</li>
                            <li>Not considering the empty string (epsilon) - check if it should be accepted</li>
                            <li>Creating non-deterministic transitions (multiple next states for same input)</li>
                            <li>Forgetting to mark the initial state or final states</li>
                        </ul>
                    </div>
                </section>

                <!-- Section 1.5 -->
                <section id="nfa">
                    <h2>1.5 Non-Deterministic Finite Automaton (NFA)</h2>

                    <p>A Non-Deterministic Finite Automaton extends DFA by allowing multiple possible next states for a given state-symbol pair, and by allowing transitions without consuming input.</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Non-Deterministic Finite Automaton (NFA)</div>
                        <p>An NFA is a 5-tuple <code>M = (Q, Sigma, delta, q0, F)</code> where:</p>
                        <ul>
                            <li><code>Q</code> = Finite, non-empty set of states</li>
                            <li><code>Sigma</code> = Input alphabet</li>
                            <li><code>delta: Q x Sigma -> P(Q)</code> = Transition function (returns a SET of states)</li>
                            <li><code>q0 in Q</code> = Initial state</li>
                            <li><code>F is a subset of Q</code> = Set of final states</li>
                        </ul>
                        <p>Note: <code>P(Q)</code> denotes the power set of Q (set of all subsets).</p>
                    </div>

                    <h3>Key Differences: DFA vs NFA</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Property</th>
                                <th>DFA</th>
                                <th>NFA</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Transition function</td>
                                <td><code>delta: Q x Sigma -> Q</code></td>
                                <td><code>delta: Q x Sigma -> P(Q)</code></td>
                            </tr>
                            <tr>
                                <td>Next state</td>
                                <td>Exactly one</td>
                                <td>Zero, one, or many</td>
                            </tr>
                            <tr>
                                <td>Determinism</td>
                                <td>Deterministic</td>
                                <td>Non-deterministic</td>
                            </tr>
                            <tr>
                                <td>Acceptance</td>
                                <td>Single computation path</td>
                                <td>At least one accepting path</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Language Accepted by NFA</h3>
                    <div class="definition-box">
                        <div class="box-title">Definition: Language of an NFA</div>
                        <p>A string w is accepted by an NFA if there EXISTS at least one computation path from the initial state to a final state while reading w.</p>
                        <p><code>L(M) = {w in Sigma* : delta*(q0, w) intersection F is not empty}</code></p>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example: NFA for strings containing "01"</div>
                        <p>Design an NFA over <code>Sigma = {0, 1}</code> that accepts all strings containing "01" as a substring.</p>

                        <p><strong>Solution:</strong></p>
                        <p>The NFA "guesses" when the substring "01" begins.</p>

                        <table class="transition-table">
                            <caption>Transition Table</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">q0</td>
                                    <td>{q0, q1}</td>
                                    <td>{q0}</td>
                                </tr>
                                <tr>
                                    <td>q1</td>
                                    <td>{}</td>
                                    <td>{q2}</td>
                                </tr>
                                <tr>
                                    <td class="state-final">q2</td>
                                    <td>{q2}</td>
                                    <td>{q2}</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="diagram-container">
                            <svg width="400" height="140" viewBox="0 0 400 140">
                                <!-- Initial arrow -->
                                <line x1="20" y1="70" x2="55" y2="70" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead3)"/>

                                <!-- State q0 -->
                                <circle cx="80" cy="70" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="80" y="75" text-anchor="middle" font-family="Georgia" font-size="14">q0</text>

                                <!-- State q1 -->
                                <circle cx="200" cy="70" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="200" y="75" text-anchor="middle" font-family="Georgia" font-size="14">q1</text>

                                <!-- State q2 (final) -->
                                <circle cx="320" cy="70" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="320" cy="70" r="20" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="320" y="75" text-anchor="middle" font-family="Georgia" font-size="14">q2</text>

                                <!-- q0 self-loop on 0,1 -->
                                <path d="M 65 50 C 50 15, 110 15, 95 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead3)"/>
                                <text x="80" y="20" text-anchor="middle" font-family="monospace" font-size="12">0, 1</text>

                                <!-- q0 to q1 on 0 -->
                                <path d="M 105 70 L 170 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead3)"/>
                                <text x="137" y="60" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- q1 to q2 on 1 -->
                                <path d="M 225 70 L 290 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead3)"/>
                                <text x="257" y="60" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- q2 self-loop on 0,1 -->
                                <path d="M 305 50 C 290 15, 350 15, 335 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead3)"/>
                                <text x="320" y="20" text-anchor="middle" font-family="monospace" font-size="12">0, 1</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead3" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.3: NFA accepting strings containing "01"</p>
                        </div>

                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li>From q0, on seeing 0, the NFA can "guess" whether this is the start of "01" (go to q1) or not (stay at q0)</li>
                            <li>From q1, only a 1 can lead to acceptance; otherwise the path dies</li>
                            <li>Once in q2, all subsequent input is accepted (loop on 0 and 1)</li>
                        </ul>
                    </div>

                    <div class="note-box">
                        <div class="box-title">Understanding Non-Determinism</div>
                        <p>Non-determinism can be understood in two ways:</p>
                        <ol>
                            <li><strong>Guessing:</strong> The NFA "guesses" the correct path to acceptance</li>
                            <li><strong>Parallel paths:</strong> The NFA explores all possible computation paths simultaneously</li>
                        </ol>
                        <p>A string is accepted if ANY path leads to a final state.</p>
                    </div>
                </section>

                <!-- Section 1.6 -->
                <section id="dfa-nfa-equivalence">
                    <h2>1.6 Equivalence of DFA and NFA</h2>

                    <div class="theorem-box">
                        <div class="box-title">Theorem: DFA-NFA Equivalence</div>
                        <p>For every NFA N, there exists a DFA D such that L(D) = L(N). That is, DFA and NFA recognize the same class of languages (regular languages).</p>
                    </div>

                    <h3>Subset Construction Algorithm</h3>
                    <p>The proof is constructive. We build an equivalent DFA from an NFA using the <strong>subset construction</strong> (also called powerset construction).</p>

                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Subset Construction (NFA to DFA)</div>
                        <p><strong>Input:</strong> NFA <code>N = (Q, Sigma, delta, q0, F)</code></p>
                        <p><strong>Output:</strong> Equivalent DFA <code>D = (Q', Sigma, delta', q0', F')</code></p>
                        <ol>
                            <li><code>Q' = P(Q)</code> (power set of Q - each DFA state is a SET of NFA states)</li>
                            <li><code>q0' = {q0}</code> (start with set containing just the NFA start state)</li>
                            <li>For each <code>S in Q'</code> and <code>a in Sigma</code>:
                                <br><code>delta'(S, a) = Union over all q in S of delta(q, a)</code></li>
                            <li><code>F' = {S in Q' : S intersection F is not empty}</code> (any set containing an NFA final state is a DFA final state)</li>
                        </ol>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example: Converting NFA to DFA</div>
                        <p>Convert the NFA for "strings containing 01" to an equivalent DFA.</p>

                        <p><strong>NFA states:</strong> {q0, q1, q2}</p>
                        <p><strong>Potential DFA states:</strong> All subsets = {}, {q0}, {q1}, {q2}, {q0,q1}, {q0,q2}, {q1,q2}, {q0,q1,q2}</p>

                        <p><strong>Building reachable states only:</strong></p>
                        <ol>
                            <li>Start: DFA state = {q0}</li>
                            <li>From {q0} on 0: delta(q0, 0) = {q0, q1}, so go to {q0, q1}</li>
                            <li>From {q0} on 1: delta(q0, 1) = {q0}, so stay at {q0}</li>
                            <li>From {q0, q1} on 0: delta(q0, 0) U delta(q1, 0) = {q0, q1} U {} = {q0, q1}</li>
                            <li>From {q0, q1} on 1: delta(q0, 1) U delta(q1, 1) = {q0} U {q2} = {q0, q2}</li>
                            <li>From {q0, q2} on 0: delta(q0, 0) U delta(q2, 0) = {q0, q1} U {q2} = {q0, q1, q2}</li>
                            <li>From {q0, q2} on 1: delta(q0, 1) U delta(q2, 1) = {q0} U {q2} = {q0, q2}</li>
                            <li>From {q0, q1, q2} on 0: {q0, q1} U {} U {q2} = {q0, q1, q2}</li>
                            <li>From {q0, q1, q2} on 1: {q0} U {q2} U {q2} = {q0, q2}</li>
                        </ol>

                        <table class="transition-table">
                            <caption>Resulting DFA Transition Table</caption>
                            <thead>
                                <tr>
                                    <th>DFA State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">{q0}</td>
                                    <td>{q0, q1}</td>
                                    <td>{q0}</td>
                                </tr>
                                <tr>
                                    <td>{q0, q1}</td>
                                    <td>{q0, q1}</td>
                                    <td>{q0, q2}</td>
                                </tr>
                                <tr>
                                    <td class="state-final">{q0, q2}</td>
                                    <td>{q0, q1, q2}</td>
                                    <td>{q0, q2}</td>
                                </tr>
                                <tr>
                                    <td class="state-final">{q0, q1, q2}</td>
                                    <td>{q0, q1, q2}</td>
                                    <td>{q0, q2}</td>
                                </tr>
                            </tbody>
                        </table>

                        <p><strong>Final states:</strong> Any state containing q2: {q0, q2}, {q0, q1, q2}</p>

                        <div class="diagram-container">
                            <svg width="450" height="200" viewBox="0 0 450 200">
                                <!-- Initial arrow -->
                                <line x1="10" y1="60" x2="35" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>

                                <!-- State A = {q0} -->
                                <circle cx="60" cy="60" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="60" y="56" text-anchor="middle" font-family="monospace" font-size="9">{q0}</text>
                                <text x="60" y="68" text-anchor="middle" font-family="Georgia" font-size="10">A</text>

                                <!-- State B = {q0,q1} -->
                                <circle cx="170" cy="60" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="170" y="56" text-anchor="middle" font-family="monospace" font-size="8">{q0,q1}</text>
                                <text x="170" y="68" text-anchor="middle" font-family="Georgia" font-size="10">B</text>

                                <!-- State C = {q0,q2} (final) -->
                                <circle cx="300" cy="60" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="300" cy="60" r="17" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="300" y="56" text-anchor="middle" font-family="monospace" font-size="8">{q0,q2}</text>
                                <text x="300" y="68" text-anchor="middle" font-family="Georgia" font-size="10">C</text>

                                <!-- State D = {q0,q1,q2} (final) -->
                                <circle cx="300" cy="150" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="300" cy="150" r="17" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="300" y="146" text-anchor="middle" font-family="monospace" font-size="7">{q0,q1,q2}</text>
                                <text x="300" y="158" text-anchor="middle" font-family="Georgia" font-size="10">D</text>

                                <!-- A self-loop on 1 -->
                                <path d="M 48 42 C 35 10, 85 10, 72 42" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="60" y="12" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- A to B on 0 -->
                                <path d="M 82 60 L 145 60" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="113" y="52" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- B self-loop on 0 -->
                                <path d="M 158 42 C 145 10, 195 10, 182 42" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="170" y="12" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- B to C on 1 -->
                                <path d="M 192 60 L 275 60" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="233" y="52" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- C self-loop on 1 -->
                                <path d="M 318 48 C 345 25, 380 45, 355 70 C 340 85, 325 75, 320 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="375" y="55" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- C to D on 0 -->
                                <path d="M 300 82 L 300 125" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="312" y="105" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- D to C on 1 -->
                                <path d="M 280 140 L 282 80" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="268" y="110" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- D self-loop on 0 -->
                                <path d="M 290 170 C 275 200, 325 200, 310 170" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead4)"/>
                                <text x="300" y="198" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead4" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.4: DFA equivalent to the NFA for "strings containing 01"</p>
                        </div>
                    </div>

                    <div class="note-box">
                        <div class="box-title">Important Observations</div>
                        <ul>
                            <li>Worst case: An NFA with n states may produce a DFA with 2^n states</li>
                            <li>In practice, many states are often unreachable, so the DFA is usually smaller</li>
                            <li>Always construct only the reachable states to save effort</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <div class="box-title">Common Mistake</div>
                        <p>When computing transitions in subset construction, don't forget to take the union of all transitions from all states in the current set. Students often compute delta(S, a) incorrectly by only considering one state from S.</p>
                    </div>
                </section>

                <!-- Section 1.7 -->
                <section id="epsilon-nfa">
                    <h2>1.7 Epsilon-NFA and Epsilon-Closure</h2>

                    <p>An Epsilon-NFA (epsilon-NFA or e-NFA) extends the NFA by allowing transitions on the empty string epsilon. These "epsilon transitions" allow the automaton to change state without consuming any input.</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Epsilon-NFA</div>
                        <p>An epsilon-NFA is a 5-tuple <code>M = (Q, Sigma, delta, q0, F)</code> where the transition function is:</p>
                        <p><code>delta: Q x (Sigma U {epsilon}) -> P(Q)</code></p>
                        <p>This allows transitions on epsilon (without reading any input symbol).</p>
                    </div>

                    <div class="definition-box">
                        <div class="box-title">Definition: Epsilon-Closure</div>
                        <p>The <strong>epsilon-closure</strong> of a state q, denoted <code>ECLOSE(q)</code> or <code>epsilon-closure(q)</code>, is the set of all states reachable from q by following zero or more epsilon transitions.</p>
                        <p>For a set of states S: <code>ECLOSE(S) = Union over all q in S of ECLOSE(q)</code></p>
                    </div>

                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Computing Epsilon-Closure</div>
                        <ol>
                            <li>Initialize: <code>ECLOSE(q) = {q}</code></li>
                            <li>Add to ECLOSE(q) all states reachable from q by a single epsilon transition</li>
                            <li>Repeat step 2 for all newly added states until no new states are added</li>
                        </ol>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example: Epsilon-NFA and Epsilon-Closure</div>
                        <p>Consider the epsilon-NFA for the language (a|b)*ab:</p>

                        <div class="diagram-container">
                            <svg width="500" height="130" viewBox="0 0 500 130">
                                <!-- Initial arrow -->
                                <line x1="10" y1="65" x2="35" y2="65" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>

                                <!-- State q0 -->
                                <circle cx="60" cy="65" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="60" y="70" text-anchor="middle" font-family="Georgia" font-size="14">q0</text>

                                <!-- State q1 -->
                                <circle cx="160" cy="65" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="160" y="70" text-anchor="middle" font-family="Georgia" font-size="14">q1</text>

                                <!-- State q2 -->
                                <circle cx="260" cy="65" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="260" y="70" text-anchor="middle" font-family="Georgia" font-size="14">q2</text>

                                <!-- State q3 -->
                                <circle cx="360" cy="65" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="360" y="70" text-anchor="middle" font-family="Georgia" font-size="14">q3</text>

                                <!-- State q4 (final) -->
                                <circle cx="460" cy="65" r="22" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="460" cy="65" r="17" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="460" y="70" text-anchor="middle" font-family="Georgia" font-size="14">q4</text>

                                <!-- q0 to q1 on epsilon -->
                                <path d="M 82 65 L 135 65" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>
                                <text x="108" y="55" text-anchor="middle" font-family="Georgia" font-size="12" font-style="italic">e</text>

                                <!-- q1 self-loop on a,b -->
                                <path d="M 148 47 C 133 12, 187 12, 172 47" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>
                                <text x="160" y="15" text-anchor="middle" font-family="monospace" font-size="11">a, b</text>

                                <!-- q1 to q2 on epsilon -->
                                <path d="M 182 65 L 235 65" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>
                                <text x="208" y="55" text-anchor="middle" font-family="Georgia" font-size="12" font-style="italic">e</text>

                                <!-- q2 to q3 on a -->
                                <path d="M 282 65 L 335 65" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>
                                <text x="308" y="55" text-anchor="middle" font-family="monospace" font-size="11">a</text>

                                <!-- q3 to q4 on b -->
                                <path d="M 382 65 L 435 65" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead5)"/>
                                <text x="408" y="55" text-anchor="middle" font-family="monospace" font-size="11">b</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead5" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.5: Epsilon-NFA for (a|b)*ab</p>
                        </div>

                        <p><strong>Computing Epsilon-Closures:</strong></p>
                        <ul>
                            <li><code>ECLOSE(q0) = {q0, q1, q2}</code> (q0 --e--> q1 --e--> q2)</li>
                            <li><code>ECLOSE(q1) = {q1, q2}</code></li>
                            <li><code>ECLOSE(q2) = {q2}</code></li>
                            <li><code>ECLOSE(q3) = {q3}</code></li>
                            <li><code>ECLOSE(q4) = {q4}</code></li>
                        </ul>
                    </div>

                    <h3>Converting Epsilon-NFA to DFA</h3>
                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Epsilon-NFA to DFA Conversion</div>
                        <p>Similar to subset construction, but with epsilon-closures:</p>
                        <ol>
                            <li>Start state of DFA: <code>ECLOSE(q0)</code></li>
                            <li>For each DFA state S and input symbol a:
                                <br><code>delta'(S, a) = ECLOSE(Union over all q in S of delta(q, a))</code></li>
                            <li>Final states: Any DFA state containing an NFA final state</li>
                        </ol>
                    </div>

                    <div class="exam-tip-box">
                        <div class="box-title">Exam Tip</div>
                        <p>When converting epsilon-NFA to DFA:</p>
                        <ol>
                            <li>Always start with ECLOSE of the initial state</li>
                            <li>For each transition, first find states reachable by the input symbol, then take ECLOSE of the result</li>
                            <li>The empty set {} may become a valid DFA state (dead state)</li>
                        </ol>
                    </div>
                </section>

                <!-- Section 1.8 -->
                <section id="moore-machine">
                    <h2>1.8 Moore Machine</h2>

                    <p>A Moore Machine is a finite state machine with output. Unlike DFA/NFA which only accept or reject strings, Moore machines produce output. The output is associated with <strong>states</strong>.</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Moore Machine</div>
                        <p>A Moore Machine is a 6-tuple <code>M = (Q, Sigma, Delta, delta, lambda, q0)</code> where:</p>
                        <ul>
                            <li><code>Q</code> = Finite set of states</li>
                            <li><code>Sigma</code> = Input alphabet</li>
                            <li><code>Delta</code> = Output alphabet</li>
                            <li><code>delta: Q x Sigma -> Q</code> = Transition function</li>
                            <li><code>lambda: Q -> Delta</code> = Output function (output depends only on state)</li>
                            <li><code>q0</code> = Initial state</li>
                        </ul>
                    </div>

                    <p><strong>Key characteristic:</strong> Output is associated with states. When entering a state, the output corresponding to that state is produced.</p>

                    <div class="example-box">
                        <div class="box-title">Example: Moore Machine for Modulo-3 Counter</div>
                        <p>Design a Moore machine that outputs the count of 1s modulo 3 seen so far.</p>
                        <p><code>Sigma = {0, 1}</code>, <code>Delta = {0, 1, 2}</code></p>

                        <table>
                            <caption>Moore Machine Table</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>Output</th>
                                    <th>Next State (0)</th>
                                    <th>Next State (1)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">q0</td>
                                    <td>0</td>
                                    <td>q0</td>
                                    <td>q1</td>
                                </tr>
                                <tr>
                                    <td>q1</td>
                                    <td>1</td>
                                    <td>q1</td>
                                    <td>q2</td>
                                </tr>
                                <tr>
                                    <td>q2</td>
                                    <td>2</td>
                                    <td>q2</td>
                                    <td>q0</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="diagram-container">
                            <svg width="420" height="150" viewBox="0 0 420 150">
                                <!-- Initial arrow -->
                                <line x1="10" y1="75" x2="38" y2="75" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>

                                <!-- State q0/0 -->
                                <circle cx="70" cy="75" r="28" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="70" y="70" text-anchor="middle" font-family="Georgia" font-size="12">q0</text>
                                <line x1="45" y1="75" x2="95" y2="75" stroke="#1a365d" stroke-width="1" stroke-dasharray="2,2" transform="translate(0,5)"/>
                                <text x="70" y="90" text-anchor="middle" font-family="monospace" font-size="12">0</text>

                                <!-- State q1/1 -->
                                <circle cx="200" cy="75" r="28" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="200" y="70" text-anchor="middle" font-family="Georgia" font-size="12">q1</text>
                                <line x1="175" y1="75" x2="225" y2="75" stroke="#1a365d" stroke-width="1" stroke-dasharray="2,2" transform="translate(0,5)"/>
                                <text x="200" y="90" text-anchor="middle" font-family="monospace" font-size="12">1</text>

                                <!-- State q2/2 -->
                                <circle cx="330" cy="75" r="28" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="330" y="70" text-anchor="middle" font-family="Georgia" font-size="12">q2</text>
                                <line x1="305" y1="75" x2="355" y2="75" stroke="#1a365d" stroke-width="1" stroke-dasharray="2,2" transform="translate(0,5)"/>
                                <text x="330" y="90" text-anchor="middle" font-family="monospace" font-size="12">2</text>

                                <!-- q0 self-loop on 0 -->
                                <path d="M 55 50 C 40 15, 100 15, 85 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="70" y="15" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- q0 to q1 on 1 -->
                                <path d="M 98 70 L 168 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="133" y="62" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- q1 self-loop on 0 -->
                                <path d="M 185 50 C 170 15, 230 15, 215 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="200" y="15" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- q1 to q2 on 1 -->
                                <path d="M 228 70 L 298 70" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="263" y="62" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- q2 self-loop on 0 -->
                                <path d="M 315 50 C 300 15, 360 15, 345 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="330" y="15" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- q2 to q0 on 1 (curved below) -->
                                <path d="M 305 95 C 280 140, 100 140, 90 95" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead6)"/>
                                <text x="200" y="140" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead6" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.6: Moore Machine - Modulo-3 Counter (state/output shown)</p>
                        </div>

                        <p><strong>Trace for input "1011":</strong></p>
                        <pre>Start in q0, output: 0
Read 1: q0 -> q1, output: 1
Read 0: q1 -> q1, output: 1
Read 1: q1 -> q2, output: 2
Read 1: q2 -> q0, output: 0

Output sequence: 0 1 1 2 0</pre>
                        <p><strong>Note:</strong> Moore machine outputs n+1 symbols for an input of length n (including initial state output).</p>
                    </div>
                </section>

                <!-- Section 1.9 -->
                <section id="mealy-machine">
                    <h2>1.9 Mealy Machine</h2>

                    <p>A Mealy Machine is another type of finite state machine with output. Unlike Moore machines, the output is associated with <strong>transitions</strong>.</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Mealy Machine</div>
                        <p>A Mealy Machine is a 6-tuple <code>M = (Q, Sigma, Delta, delta, lambda, q0)</code> where:</p>
                        <ul>
                            <li><code>Q</code> = Finite set of states</li>
                            <li><code>Sigma</code> = Input alphabet</li>
                            <li><code>Delta</code> = Output alphabet</li>
                            <li><code>delta: Q x Sigma -> Q</code> = Transition function</li>
                            <li><code>lambda: Q x Sigma -> Delta</code> = Output function (output depends on state AND input)</li>
                            <li><code>q0</code> = Initial state</li>
                        </ul>
                    </div>

                    <p><strong>Key characteristic:</strong> Output is associated with transitions. Output is produced when a transition is made.</p>

                    <div class="example-box">
                        <div class="box-title">Example: Mealy Machine for 1's Complement</div>
                        <p>Design a Mealy machine that outputs the 1's complement of the input (flip 0s and 1s).</p>
                        <p><code>Sigma = {0, 1}</code>, <code>Delta = {0, 1}</code></p>

                        <table>
                            <caption>Mealy Machine Table</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>Input 0</th>
                                    <th>Input 1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="state-initial">q0</td>
                                    <td>q0 / 1</td>
                                    <td>q0 / 0</td>
                                </tr>
                            </tbody>
                        </table>
                        <p><em>Format: next-state / output</em></p>

                        <div class="diagram-container">
                            <svg width="200" height="120" viewBox="0 0 200 120">
                                <!-- Initial arrow -->
                                <line x1="20" y1="60" x2="55" y2="60" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead7)"/>

                                <!-- State q0 -->
                                <circle cx="100" cy="60" r="30" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="100" y="65" text-anchor="middle" font-family="Georgia" font-size="14">q0</text>

                                <!-- Self-loop on top for 0/1 -->
                                <path d="M 80 35 C 65 -5, 135 -5, 120 35" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead7)"/>
                                <text x="100" y="5" text-anchor="middle" font-family="monospace" font-size="11">0 / 1</text>

                                <!-- Self-loop on bottom for 1/0 -->
                                <path d="M 80 85 C 65 125, 135 125, 120 85" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead7)"/>
                                <text x="100" y="115" text-anchor="middle" font-family="monospace" font-size="11">1 / 0</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead7" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.7: Mealy Machine - 1's Complement (input/output on transitions)</p>
                        </div>

                        <p><strong>Trace for input "1010":</strong></p>
                        <pre>Read 1: q0 -> q0, output: 0
Read 0: q0 -> q0, output: 1
Read 1: q0 -> q0, output: 0
Read 0: q0 -> q0, output: 1

Output sequence: 0 1 0 1</pre>
                        <p><strong>Note:</strong> Mealy machine outputs exactly n symbols for an input of length n.</p>
                    </div>
                </section>

                <!-- Section 1.10 -->
                <section id="moore-mealy-equivalence">
                    <h2>1.10 Moore-Mealy Equivalence</h2>

                    <div class="theorem-box">
                        <div class="box-title">Theorem: Moore-Mealy Equivalence</div>
                        <p>For every Moore machine, there exists an equivalent Mealy machine, and vice versa. The machines are equivalent in terms of the input-output relationship (ignoring the extra initial output of Moore machines).</p>
                    </div>

                    <h3>Comparison Table</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Property</th>
                                <th>Moore Machine</th>
                                <th>Mealy Machine</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Output association</td>
                                <td>States</td>
                                <td>Transitions</td>
                            </tr>
                            <tr>
                                <td>Output function</td>
                                <td>lambda: Q -> Delta</td>
                                <td>lambda: Q x Sigma -> Delta</td>
                            </tr>
                            <tr>
                                <td>Output for input of length n</td>
                                <td>n + 1 symbols</td>
                                <td>n symbols</td>
                            </tr>
                            <tr>
                                <td>When output is determined</td>
                                <td>At state entry</td>
                                <td>During transition</td>
                            </tr>
                            <tr>
                                <td>Number of states</td>
                                <td>Generally more</td>
                                <td>Generally fewer</td>
                            </tr>
                            <tr>
                                <td>Response to input change</td>
                                <td>Delayed (after state change)</td>
                                <td>Immediate</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Conversion: Moore to Mealy</h3>
                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Moore to Mealy Conversion</div>
                        <p>Given Moore machine <code>(Q, Sigma, Delta, delta_M, lambda_M, q0)</code>:</p>
                        <ol>
                            <li>Same state set Q</li>
                            <li>Same transition function delta</li>
                            <li>Output function: <code>lambda(q, a) = lambda_M(delta_M(q, a))</code>
                                <br>(Output is the Moore output of the destination state)</li>
                        </ol>
                    </div>

                    <h3>Conversion: Mealy to Moore</h3>
                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Mealy to Moore Conversion</div>
                        <p>Given Mealy machine <code>(Q, Sigma, Delta, delta_Y, lambda_Y, q0)</code>:</p>
                        <ol>
                            <li>Create new states: For each Mealy state q and each possible output o that can lead to q, create state (q, o)</li>
                            <li>Transition: <code>delta((q, o), a) = (delta_Y(q, a), lambda_Y(q, a))</code></li>
                            <li>Moore output: <code>lambda(q, o) = o</code></li>
                            <li>Start state: (q0, o0) where o0 is a default initial output</li>
                        </ol>
                        <p><strong>Note:</strong> The equivalent Moore machine may have up to |Q| x |Delta| states.</p>
                    </div>

                    <div class="warning-box">
                        <div class="box-title">Common Mistake</div>
                        <p>When converting Moore to Mealy, don't forget that the output depends on the DESTINATION state, not the source state. The formula is lambda_Mealy(q, a) = lambda_Moore(delta(q, a)).</p>
                    </div>
                </section>

                <!-- Section 1.11 -->
                <section id="dfa-minimization">
                    <h2>1.11 DFA Minimization</h2>

                    <p>DFA minimization is the process of finding the smallest (fewest states) DFA that accepts the same language as a given DFA. The minimal DFA is unique (up to state renaming).</p>

                    <div class="definition-box">
                        <div class="box-title">Definition: Distinguishable States</div>
                        <p>Two states p and q are <strong>distinguishable</strong> if there exists a string w such that exactly one of delta*(p, w) and delta*(q, w) is a final state.</p>
                        <p>Two states are <strong>equivalent (indistinguishable)</strong> if no such string exists.</p>
                    </div>

                    <h3>Table-Filling Algorithm (Myhill-Nerode)</h3>
                    <div class="algorithm">
                        <div class="algorithm-title">Algorithm: Table-Filling Method for DFA Minimization</div>
                        <ol>
                            <li><strong>Create a table</strong> with all pairs of states (p, q) where p is not equal to q</li>
                            <li><strong>Base case:</strong> Mark all pairs (p, q) where exactly one of p, q is a final state (they are distinguishable by epsilon)</li>
                            <li><strong>Inductive step:</strong> For each unmarked pair (p, q) and each input symbol a:
                                <ul>
                                    <li>If (delta(p, a), delta(q, a)) is marked, then mark (p, q)</li>
                                </ul>
                            </li>
                            <li><strong>Repeat step 3</strong> until no new pairs are marked</li>
                            <li><strong>Merge:</strong> All unmarked pairs represent equivalent states - merge them</li>
                        </ol>
                    </div>

                    <div class="example-box">
                        <div class="box-title">Example: DFA Minimization</div>
                        <p>Minimize the following DFA:</p>

                        <table class="transition-table">
                            <caption>Original DFA</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td class="state-initial">A</td><td>B</td><td>C</td></tr>
                                <tr><td>B</td><td>D</td><td>E</td></tr>
                                <tr><td class="state-final">C</td><td>F</td><td>C</td></tr>
                                <tr><td>D</td><td>D</td><td>E</td></tr>
                                <tr><td class="state-final">E</td><td>F</td><td>C</td></tr>
                                <tr><td class="state-final">F</td><td>F</td><td>C</td></tr>
                            </tbody>
                        </table>

                        <p><strong>Step 1:</strong> Draw the table for pairs:</p>
                        <pre>
     A    B    C    D    E
B
C
D
E
F    </pre>

                        <p><strong>Step 2:</strong> Mark pairs with one final, one non-final state (base case):</p>
                        <p>Final states: C, E, F. Non-final states: A, B, D</p>
                        <p>Mark: (A,C), (A,E), (A,F), (B,C), (B,E), (B,F), (D,C), (D,E), (D,F)</p>

                        <pre>
     A    B    C    D    E
B    -
C    X    X
D    -    -    X
E    X    X    -    X
F    X    X    -    X    -</pre>

                        <p><strong>Step 3:</strong> Check remaining pairs:</p>
                        <ul>
                            <li>(A, B): delta(A,0)=B, delta(B,0)=D. Is (B,D) marked? No.
                                <br>delta(A,1)=C, delta(B,1)=E. Is (C,E) marked? No. Keep unmarked.</li>
                            <li>(A, D): delta(A,0)=B, delta(D,0)=D. Is (B,D) marked? No.
                                <br>delta(A,1)=C, delta(D,1)=E. Is (C,E) marked? No. Keep unmarked.</li>
                            <li>(B, D): delta(B,0)=D, delta(D,0)=D. Same state - ok.
                                <br>delta(B,1)=E, delta(D,1)=E. Same state - ok. Keep unmarked.</li>
                            <li>(C, E): delta(C,0)=F, delta(E,0)=F. Same state - ok.
                                <br>delta(C,1)=C, delta(E,1)=C. Same state - ok. Keep unmarked.</li>
                            <li>(C, F): delta(C,0)=F, delta(F,0)=F. Same state - ok.
                                <br>delta(C,1)=C, delta(F,1)=C. Same state - ok. Keep unmarked.</li>
                            <li>(E, F): delta(E,0)=F, delta(F,0)=F. Same state - ok.
                                <br>delta(E,1)=C, delta(F,1)=C. Same state - ok. Keep unmarked.</li>
                        </ul>

                        <p><strong>Step 4:</strong> Second iteration check:</p>
                        <ul>
                            <li>(A, B): Check again - (B,D) unmarked, (C,E) unmarked. Still unmarked.</li>
                            <li>(A, D): (B,D) unmarked, (C,E) unmarked. Still unmarked.</li>
                        </ul>

                        <p><strong>Final table:</strong></p>
                        <pre>
     A    B    C    D    E
B    -
C    X    X
D    -    -    X
E    X    X    -    X
F    X    X    -    X    -</pre>

                        <p><strong>Step 5:</strong> Equivalent state groups:</p>
                        <ul>
                            <li>{A, B, D} - all pairs are unmarked among these</li>
                            <li>{C, E, F} - all pairs are unmarked among these</li>
                        </ul>

                        <p><strong>Minimized DFA:</strong></p>
                        <table class="transition-table">
                            <caption>Minimized DFA</caption>
                            <thead>
                                <tr>
                                    <th>State</th>
                                    <th>0</th>
                                    <th>1</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td class="state-initial">S0 (= ABD)</td><td>S0</td><td>S1</td></tr>
                                <tr><td class="state-final">S1 (= CEF)</td><td>S1</td><td>S1</td></tr>
                            </tbody>
                        </table>

                        <div class="diagram-container">
                            <svg width="250" height="100" viewBox="0 0 250 100">
                                <!-- Initial arrow -->
                                <line x1="10" y1="50" x2="38" y2="50" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead8)"/>

                                <!-- State S0 -->
                                <circle cx="70" cy="50" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="70" y="55" text-anchor="middle" font-family="Georgia" font-size="14">S0</text>

                                <!-- State S1 (final) -->
                                <circle cx="180" cy="50" r="25" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <circle cx="180" cy="50" r="20" fill="white" stroke="#1a365d" stroke-width="2"/>
                                <text x="180" y="55" text-anchor="middle" font-family="Georgia" font-size="14">S1</text>

                                <!-- S0 self-loop on 0 -->
                                <path d="M 55 30 C 40 -5, 100 -5, 85 30" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead8)"/>
                                <text x="70" y="5" text-anchor="middle" font-family="monospace" font-size="11">0</text>

                                <!-- S0 to S1 on 1 -->
                                <path d="M 95 50 L 150 50" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead8)"/>
                                <text x="122" y="42" text-anchor="middle" font-family="monospace" font-size="11">1</text>

                                <!-- S1 self-loop on 0,1 -->
                                <path d="M 165 30 C 150 -5, 210 -5, 195 30" fill="none" stroke="#1a365d" stroke-width="2" marker-end="url(#arrowhead8)"/>
                                <text x="180" y="5" text-anchor="middle" font-family="monospace" font-size="11">0, 1</text>

                                <!-- Arrow marker definition -->
                                <defs>
                                    <marker id="arrowhead8" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#1a365d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <p class="diagram-caption">Figure 1.8: Minimized DFA (from 6 states to 2 states)</p>
                        </div>
                    </div>

                    <div class="theorem-box">
                        <div class="box-title">Theorem: Uniqueness of Minimal DFA</div>
                        <p>For any regular language, there exists a unique minimum-state DFA (up to isomorphism/renaming of states). This minimal DFA can be found using the table-filling algorithm.</p>
                    </div>

                    <div class="exam-tip-box">
                        <div class="box-title">Exam Tips for DFA Minimization</div>
                        <ul>
                            <li>Always start by marking pairs where one state is final and the other is not</li>
                            <li>Keep iterating the marking step until no new marks are added</li>
                            <li>Handle unreachable states first - remove them before minimization</li>
                            <li>The resulting groups form the states of the minimal DFA</li>
                            <li>Initial state of minimal DFA: group containing original initial state</li>
                            <li>Final states of minimal DFA: groups containing original final states</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <div class="box-title">Common Mistakes in DFA Minimization</div>
                        <ul>
                            <li>Forgetting to remove unreachable states before starting</li>
                            <li>Not continuing the marking process until no changes occur</li>
                            <li>Incorrectly computing transitions for the minimized DFA</li>
                            <li>Forgetting that equivalent states must have the same "finality" (both final or both non-final)</li>
                        </ul>
                    </div>
                </section>

                <!-- Unit Summary -->
                <section id="summary" class="unit-summary">
                    <h2>Unit I Summary</h2>

                    <h3>Key Results</h3>
                    <ul class="key-results">
                        <li>DFA, NFA, and epsilon-NFA are all equivalent in expressive power - they recognize exactly the regular languages</li>
                        <li>Subset construction converts NFA to DFA (potentially exponential blowup: n states -> up to 2^n states)</li>
                        <li>Moore and Mealy machines are equivalent in terms of input-output behavior</li>
                        <li>Every regular language has a unique minimal DFA (up to isomorphism)</li>
                        <li>The table-filling algorithm produces the minimal DFA</li>
                    </ul>

                    <h3>Exam-Important Definitions</h3>
                    <ul>
                        <li><strong>DFA:</strong> 5-tuple (Q, Sigma, delta, q0, F) with deterministic transitions</li>
                        <li><strong>NFA:</strong> Same structure but delta returns a SET of states</li>
                        <li><strong>Epsilon-closure:</strong> Set of states reachable by zero or more epsilon transitions</li>
                        <li><strong>Distinguishable states:</strong> States p, q where some string leads one to final and other to non-final</li>
                    </ul>

                    <h3>Common Mistakes to Avoid</h3>
                    <ul class="common-mistakes">
                        <li>Confusing {} (empty language) with {epsilon} (language containing empty string)</li>
                        <li>Making incomplete DFAs (missing transitions)</li>
                        <li>Forgetting epsilon-closure when converting epsilon-NFA to DFA</li>
                        <li>In Moore-to-Mealy conversion, associating output with source state instead of destination</li>
                        <li>Not iterating the marking algorithm until convergence in DFA minimization</li>
                    </ul>

                    <h3>Algorithms to Know</h3>
                    <ul>
                        <li>Subset Construction (NFA to DFA)</li>
                        <li>Epsilon-NFA to NFA conversion</li>
                        <li>Moore to Mealy and Mealy to Moore conversion</li>
                        <li>Table-Filling Algorithm for DFA minimization</li>
                    </ul>
                </section>

            </article>
        </div>
    </main>

    <footer class="page-footer">
        <p>TAFL Study Guide - Unit I: Basic Concepts and Automata Theory</p>
        <p><a href="unit2.html">Continue to Unit II: Regular Expressions and Languages</a></p>
    </footer>
</body>
</html>
